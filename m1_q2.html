<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Foundational Skills – Question 2</title>
  <link rel="stylesheet" href="css/style.css" />
  <style>
    .question{
      padding:1.25rem 1.25rem 1rem;border:1px solid #e5e7eb;border-radius:12px;background:#fff;
      box-shadow:0 6px 16px rgba(0,0,0,.04);margin:1rem 0;
    }
    .qtext{font-size:1.05rem;line-height:1.5}
    .answer{margin-top:1rem}
  </style>
</head>
<body>
  <div class="progress"><i style="width:55%"></i></div>

  <main class="container" role="main">
    <h2>Foundational Skills — Question 2</h2>
    <p class="sub">This question adapts based on how Question 1 went.</p>

    <div id="qbox" class="question" aria-live="polite">
      <div id="qtext" class="qtext"></div>
      <div class="answer">
        <label for="resp" class="helper">Your answer</label>
        <input id="resp" class="input" autocomplete="off" />
      </div>
    </div>

    <div class="actions" style="justify-content:space-between">
      <button class="btn" type="button" onclick="window.location.href='m1_q1.html'">Back</button>
      <button id="submitBtn" class="btn" type="button">Continue</button>
    </div>
    <p id="msg" class="helper" style="display:none;color:#b91c1c">Please enter an answer.</p>
  </main>

  <script type="module">
    import { getKV, setKV, setProgress } from './js/app.js';
    setProgress(55);

    const QUESTIONS = getKV('m1_questions', []);  // [{id,text}]
    const RANK      = getKV('m1_ranking', []);    // ['fs1',...], easiest -> hardest
    const CONF      = getKV('m1_confidence', {}); // { fs1:'H'|'M'|'L' }
    const Q1        = getKV('m1_q1', null);       // { id, text, correct }
    const ASKED     = getKV('m1_asked', []);      // ['fsX', ...]

    if (!Q1 || !Array.isArray(RANK) || RANK.length === 0 || QUESTIONS.length === 0){
      // Not enough context; send back to ranking start of module
      window.location.href = 'm1_ranking.html';
    }

    const byId = id => QUESTIONS.find(q => q.id === id);
    const rankIndex = id => RANK.indexOf(id);

    // Build groups (arrays ordered easiest->hardest by rank)
    const H = RANK.filter(id => CONF[id] === 'H');
    const M = RANK.filter(id => CONF[id] === 'M');
    const L = RANK.filter(id => CONF[id] === 'L');

    const currentId = Q1.id;
    const currentConf = CONF[currentId];      // 'H'|'M'|'L'
    const currentIdx  = rankIndex(currentId); // position in RANK
    const wantHarder  = Q1.correct === true;  // if correct, go harder; else easier
    const dir = wantHarder ? +1 : -1;

    function nextInSameGroup(id){
      const group = currentConf === 'H' ? H : currentConf === 'M' ? M : L;
      const i = group.indexOf(id);
      if (i === -1) return null;
      const j = i + dir;
      if (j < 0 || j >= group.length) return null; // no neighbor in desired direction
      const candidate = group[j];
      return ASKED.includes(candidate) ? null : candidate;
    }

    function nearestAvailableByRank(){
      // Choose the closest item by rank distance in the desired direction, across ALL groups,
      // excluding already asked and excluding the current Q1 id.
      const candidates = RANK
        .filter(id => !ASKED.includes(id) && id !== currentId)
        .filter(id => (wantHarder ? rankIndex(id) > currentIdx : rankIndex(id) < currentIdx));

      if (candidates.length === 0) return null;

      // pick the one with minimal absolute distance in rank
      let best = null, bestDist = Infinity;
      candidates.forEach(id => {
        const d = Math.abs(rankIndex(id) - currentIdx);
        if (d < bestDist){ bestDist = d; best = id; }
      });
      return best;
    }

    // Try same group first
    let q2Id = nextInSameGroup(currentId);

    // Fallback to nearest available item (any group) in the desired direction
    if (!q2Id){
      q2Id = nearestAvailableByRank();
    }

    // Absolute fallback: any not-asked item (should be rare)
    if (!q2Id){
      q2Id = RANK.find(id => !ASKED.includes(id) && id !== currentId) || currentId;
    }

    const q2 = byId(q2Id);
    if (!q2){
      window.location.href = 'm1_ranking.html';
    }

    // Render the chosen question
    document.getElementById('qtext').textContent = q2.text;

    // ----- Minimal correctness checks (same rules as Q1) -----
    function normalize(s){ return (s||'').toString().trim().toLowerCase().replace(/\s+/g,''); }
    function checkAnswer(id, raw){
      const a = normalize(raw);
      switch(id){
        case 'fs1': return a === '8y-2' || a === '-2+8y';
        case 'fs2': return a === '13';
        case 'fs3': return /^15\*?h\+40$/.test(a) || /^40\+15\*?h$/.test(a);
        case 'fs4': return a === '-2x+7' || a === '7-2x';
        case 'fs5': return a === '4a-8' || a === '-8+4a';
        default:    return false;
      }
    }

    const submitBtn = document.getElementById('submitBtn');
    const msg = document.getElementById('msg');
    const resp = document.getElementById('resp');

    submitBtn.addEventListener('click', ()=>{
      const val = resp.value;
      if(!val || !val.trim()){
        msg.style.display = 'block';
        return;
      }
      msg.style.display = 'none';

      const correct = checkAnswer(q2Id, val);

      setKV('m1_q2', {
        id: q2Id,
        text: q2.text,
        answer: val,
        correct,
        basedOn: { q1: Q1.id, q1Correct: Q1.correct }
      });

      const asked = getKV('m1_asked', []);
      if(!asked.includes(q2Id)){
        asked.push(q2Id);
        setKV('m1_asked', asked);
      }

      // Go to Module 1 reflection
      window.location.href = 'm1_reflection.html';
    });
  </script>
</body>
</html>
